[ ] NAME:Current Task List DESCRIPTION:Root task for conversation __NEW_AGENT__
-[x] NAME:Commit current state before implementing optimistic queue pattern DESCRIPTION:Create a git commit with all current changes to establish a safe restore point before implementing the comprehensive optimistic queue pattern. This allows easy revert if issues arise. Commit message should be: 'feat: optimistic UI updates with useOptimisticArray - pre-queue-pattern checkpoint'
-[x] NAME:Phase 1: Create useOptimisticQueue helper utility DESCRIPTION:Create src/lib/utils/useOptimisticQueue.svelte.ts with comprehensive queue management. Implement: 1) QueueStatus type ('saving'|'saved'|'error'), 2) useOptimisticQueue function accepting parentArray and opts (onCreate, onDelete callbacks), 3) Local state for items array and statuses Map, 4) $effect to sync with parent and cleanup stale statuses, 5) Methods: add(draft) - creates temp id, sets saving status, calls onCreate, replaces temp with real item or marks error, 6) remove(id) - handles temp ids locally, real ids via onDelete with status tracking, 7) retry(id, draft) - re-attempts failed operations, 8) getStatus(id) - returns current status, 9) Getters for value (items array) and statuses (readonly Map). Include comprehensive JSDoc comments explaining usage patterns.
-[x] NAME:Phase 2.1: Update parent accessory handlers to support queue pattern DESCRIPTION:Modify src/routes/(app)/work/assessments/[appointment_id]/+page.svelte accessory handlers: 1) Update handleAddAccessory to return Promise<VehicleAccessory> instead of Promise<void> - return the created accessory from accessoriesService.create, 2) Add temp ID guard in handleDeleteAccessory - check if (!id.startsWith('temp-')) before calling accessoriesService.delete, 3) Update Props interface in Exterior360Tab to reflect Promise<VehicleAccessory> return type for onAddAccessory and Promise<void> for onDeleteAccessory, 4) Ensure proper error propagation by rethrowing errors after logging.
-[x] NAME:Phase 2.2: Integrate useOptimisticQueue into Exterior360Tab for accessories DESCRIPTION:Update src/lib/components/assessment/Exterior360Tab.svelte: 1) Import useOptimisticQueue from utils, 2) Replace useOptimisticArray(props.accessories) with useOptimisticQueue(props.accessories, { onCreate: async (draft) => await onAddAccessory(...), onDelete: async (id) => await onDeleteAccessory(id) }), 3) Update handleAddAccessory to use queue.add() instead of accessories.add(), remove manual temp accessory creation, 4) Create helper functions: isSaving(id), hasError(id), 5) Update template to use accessories.value instead of accessories, 6) Add disabled={isSaving(accessory.id)} to delete buttons, 7) Add loading spinner (Loader2 with animate-spin) next to accessories with saving status, 8) Add retry button for accessories with error status that calls queue.retry(), 9) Update all references from accessories to accessories.value throughout template.
-[/] NAME:Phase 2.3: Test accessories optimistic queue implementation DESCRIPTION:Thoroughly test Exterior360Tab accessories: 1) Add single accessory - verify immediate appearance with spinner, then saved state, 2) Add multiple accessories rapidly - verify all appear with spinners, all transition to saved, 3) Try to delete while saving - verify button is disabled, 4) Delete temp accessory immediately after add - verify no DB error, local removal only, 5) Delete saved accessory - verify DB delete + UI removal, 6) Simulate network error (disconnect) - verify error state appears with retry button, 7) Click retry - verify re-attempt and success, 8) Verify no console errors or TypeScript issues, 9) Check that accessories sync properly when navigating away and back.
-[x] NAME:Phase 3.1: Update parent estimate line item handlers for queue pattern DESCRIPTION:Modify src/routes/(app)/work/assessments/[appointment_id]/+page.svelte estimate handlers: 1) Update handleAddLineItem signature to return Promise<EstimateLineItem> - extract and return the added line item from updatedEstimate.line_items, 2) Update handleUpdateLineItem to return Promise<EstimateLineItem> - return the updated item, 3) Ensure handleDeleteLineItem and handleBulkDeleteLineItems return Promise<void> explicitly, 4) Add temp ID guards in delete handlers to skip DB operations for temp- prefixed IDs, 5) Update Props interface in EstimateTab to reflect new return types, 6) Ensure all handlers properly propagate errors by rethrowing after logging.
-[ ] NAME:Phase 3.2: Integrate useOptimisticQueue into EstimateTab for line items DESCRIPTION:Update src/lib/components/assessment/EstimateTab.svelte: 1) Import useOptimisticQueue, 2) Create itemsQueue = useOptimisticQueue(estimate?.line_items ?? [], { onCreate: async (draft) => await onAddLineItem(draft), onDelete: async (id) => await onDeleteLineItem(id) }), 3) Update ItemTable component to accept queue instead of raw array, pass statuses, 4) Create helper functions: isSavingItem(id), hasErrorItem(id), 5) In ItemTable, disable edit/delete buttons when isSavingItem(item.id), 6) Add small Loader2 spinner in Total column for rows with saving status, 7) Add retry button in actions column for rows with error status, 8) Update bulk delete to set saving status for all selected items before calling onBulkDeleteLineItems, disable 'Delete Selected' button while any selected item is saving, 9) Update all line_items references to use itemsQueue.value, 10) Handle add empty row to use queue.add() with temp ID.
-[ ] NAME:Phase 3.3: Update AdditionalsTab line items for queue pattern DESCRIPTION:Apply same queue pattern to src/lib/components/assessment/AdditionalsTab.svelte: 1) Import useOptimisticQueue, 2) Update parent handlers in +page.svelte for additionals (handleAddAdditionalLineItem, handleUpdateAdditionalLineItem, handleDeleteAdditionalLineItem) to return appropriate types and handle temp IDs, 3) Create additionalsQueue with onCreate/onDelete callbacks, 4) Update ItemTable usage to pass queue and statuses, 5) Disable approve/decline/edit/delete buttons while item is saving, 6) Add loading spinners for saving items, 7) Add retry buttons for error items, 8) Update all line_items references to additionalsQueue.value.
-[ ] NAME:Phase 3.4: Update FRCTab line items for queue pattern DESCRIPTION:Apply queue pattern to src/lib/components/assessment/FRCTab.svelte: 1) Import useOptimisticQueue, 2) Update parent handlers for FRC line items (approve/decline/update) to handle temp IDs and return appropriate types, 3) Create frcQueue for line items, 4) Disable approve/decline/corrected value inputs while item is saving, 5) Add loading indicators for items being processed, 6) Add retry for failed approve/decline operations, 7) Update all line_items references to frcQueue.value.
-[ ] NAME:Phase 3.5: Test line items optimistic queue implementation DESCRIPTION:Thoroughly test all line item implementations: 1) EstimateTab - add multiple line items rapidly, verify spinners and saved states, try editing/deleting while saving (should be disabled), bulk delete multiple items, 2) AdditionalsTab - add additional line items, approve/decline with loading states, verify error handling and retry, 3) FRCTab - approve/decline line items with loading feedback, test corrected values with saving state, 4) Verify no race conditions when adding/editing/deleting rapidly, 5) Test error scenarios (network disconnect) and retry functionality, 6) Verify line item totals recalculate correctly during optimistic updates, 7) Check that all tabs sync properly when navigating between them.
-[ ] NAME:Phase 4.1: Update parent photo handlers for queue pattern DESCRIPTION:Modify src/routes/(app)/work/assessments/[appointment_id]/+page.svelte photo-related handlers: 1) Ensure photo update callbacks return Promise<void> explicitly, 2) Add error propagation for photo operations, 3) Update Props interfaces in photo panel components to reflect Promise return types, 4) Consider adding temp ID guards if photos use temp IDs during upload (though storage upload completes before DB create, so may not be needed).
-[ ] NAME:Phase 4.2: Integrate useOptimisticQueue into EstimatePhotosPanel DESCRIPTION:Update src/lib/components/assessment/EstimatePhotosPanel.svelte: 1) Import useOptimisticQueue, 2) Replace useOptimisticArray with useOptimisticQueue(props.photos, { onCreate: async (draft) => { const displayOrder = await estimatePhotosService.getNextDisplayOrder(estimateId); return await estimatePhotosService.createPhoto({ estimate_id: estimateId, photo_url: draft.photo_url, photo_path: draft.photo_path, display_order }); }, onDelete: async (id) => { const photo = photosQueue.value.find(p => p.id === id); if (photo?.photo_path) await storageService.deletePhoto(photo.photo_path); await estimatePhotosService.deletePhoto(id); } }), 3) Update uploadFiles to call photosQueue.add() after storage upload with temp photo object, 4) Create isSavingPhoto(id) helper, 5) Disable delete button while photo is saving, 6) Add small loading indicator on photo card while saving, 7) Add retry button for photos with error status, 8) Update all photos references to photosQueue.value, 9) Keep existing uploading state and progress bar for storage upload phase.
-[ ] NAME:Phase 4.3: Integrate useOptimisticQueue into PreIncidentPhotosPanel DESCRIPTION:Update src/lib/components/assessment/PreIncidentPhotosPanel.svelte with same pattern as EstimatePhotosPanel: 1) Import useOptimisticQueue, 2) Replace useOptimisticArray with useOptimisticQueue using preIncidentEstimatePhotosService, 3) Update uploadFiles to use queue.add() after storage upload, 4) Add isSavingPhoto helper and disable delete while saving, 5) Add loading indicators and retry buttons, 6) Update all photos references to photosQueue.value, 7) Maintain existing upload progress UI.
-[ ] NAME:Phase 4.4: Integrate useOptimisticQueue into AdditionalsPhotosPanel DESCRIPTION:Update src/lib/components/assessment/AdditionalsPhotosPanel.svelte with queue pattern: 1) Import useOptimisticQueue, 2) Replace useOptimisticArray with useOptimisticQueue using additionalsPhotosService, 3) Update uploadFiles to use queue.add() after storage upload, 4) Add isSavingPhoto helper and disable delete while saving, 5) Add loading indicators and retry buttons, 6) Update all photos references to photosQueue.value, 7) Maintain existing upload progress UI.
-[ ] NAME:Phase 4.5: Test photo panels optimistic queue implementation DESCRIPTION:Thoroughly test all photo panel implementations: 1) EstimatePhotosPanel - upload single photo, verify storage upload progress then DB create with spinner, upload multiple photos rapidly, try deleting while saving (should be disabled), delete saved photo successfully, 2) PreIncidentPhotosPanel - same tests as estimate photos, 3) AdditionalsPhotosPanel - same tests, 4) Test error scenarios - simulate storage failure, simulate DB create failure, verify retry buttons appear and work, 5) Test photo labeling while photo is saving, 6) Verify photo modals work correctly with queue pattern, 7) Check that display_order is maintained correctly, 8) Verify no duplicate photos appear during optimistic updates.
-[ ] NAME:Phase 5.1: Update TypeScript interfaces for queue pattern DESCRIPTION:Review and update type definitions: 1) Check src/lib/types/assessment.ts for any interfaces that need QueueStatus or queue-related types, 2) Ensure all callback Props interfaces across components use Promise return types consistently, 3) Add JSDoc comments to explain queue-related props, 4) Export QueueStatus type from useOptimisticQueue for use in components, 5) Verify no TypeScript errors across all modified files.
-[ ] NAME:Phase 5.2: Add visual consistency for loading states across all components DESCRIPTION:Ensure consistent UX for loading/error states: 1) Standardize spinner size and color (Loader2 with h-4 w-4 animate-spin text-blue-500), 2) Standardize error icon (AlertCircle with h-4 w-4 text-red-500), 3) Standardize success icon if showing saved state (CheckCircle with h-4 w-4 text-green-500), 4) Standardize retry button styling (size='sm' variant='outline'), 5) Ensure disabled states have consistent opacity and cursor-not-allowed, 6) Add tooltips to disabled buttons explaining 'Saving...' or 'Please wait', 7) Consider adding subtle pulse animation to saving items for better visibility.
-[ ] NAME:Phase 5.3: Add error handling and user feedback improvements DESCRIPTION:Enhance error handling across queue implementations: 1) Add toast notifications for successful saves (optional, subtle), 2) Add toast notifications for errors with actionable messages, 3) Implement automatic retry with exponential backoff for network errors (optional enhancement), 4) Add error logging to help debug issues in production, 5) Consider adding a global 'unsaved changes' indicator if any items are in saving or error state, 6) Add confirmation dialogs before retrying failed operations that might have side effects, 7) Ensure error messages are user-friendly and actionable.
-[ ] NAME:Phase 5.4: Comprehensive integration testing DESCRIPTION:Perform end-to-end testing of entire queue pattern implementation: 1) Test complete assessment workflow from start to finish with rapid data entry, 2) Test switching between tabs while items are saving - verify state persists correctly, 3) Test browser refresh while items are saving - verify graceful handling (items may be lost, but no errors), 4) Test concurrent operations - add/edit/delete multiple items across different tabs simultaneously, 5) Test with slow network (throttle to 3G) - verify all loading states appear and work correctly, 6) Test with network disconnection - verify error states and retry functionality, 7) Test edge cases - empty arrays, single items, bulk operations, 8) Verify no memory leaks from status Maps or $effects, 9) Test on different browsers (Chrome, Firefox, Safari), 10) Verify mobile responsiveness of loading indicators and retry buttons.
-[ ] NAME:Phase 5.5: Update documentation and code comments DESCRIPTION:Document the queue pattern implementation: 1) Update COMPONENTS.md with useOptimisticQueue usage examples, 2) Add inline comments explaining queue pattern in complex sections, 3) Document the temp ID convention (temp-{timestamp}) and why it's used, 4) Document error handling patterns and retry behavior, 5) Add troubleshooting section for common issues (e.g., items stuck in saving state), 6) Document performance considerations (status Map cleanup, $effect dependencies), 7) Add migration notes for future developers explaining the pattern, 8) Update any existing documentation that references useOptimisticArray to mention useOptimisticQueue as the preferred approach.
-[ ] NAME:Phase 5.6: Performance optimization and cleanup DESCRIPTION:Optimize queue pattern implementation: 1) Review $effect dependencies to ensure minimal re-runs, 2) Consider debouncing status updates if they cause excessive re-renders, 3) Ensure status Map cleanup happens efficiently (remove stale entries), 4) Profile components with queue pattern to identify any performance bottlenecks, 5) Consider lazy loading retry functionality if not commonly used, 6) Remove old useOptimisticArray usage if no longer needed (or keep for simpler use cases), 7) Clean up any console.log statements used during development, 8) Ensure proper cleanup in component unmount (though Svelte handles this automatically).
-[ ] NAME:Phase 5.8: Remove redundant code and cleanup old patterns DESCRIPTION:Clean up codebase after queue pattern implementation: 1) Search for any remaining useOptimisticArray imports that should be replaced with useOptimisticQueue, 2) Check if useOptimisticArray.svelte.ts is still needed or can be removed (keep only if used elsewhere or for backward compatibility), 3) Remove any commented-out code from the refactoring, 4) Search for and remove any temp ID handling code that's now redundant (e.g., duplicate temp- checks), 5) Remove unused imports (Loader2, AlertCircle, CheckCircle if not used), 6) Clean up any duplicate helper functions (isSaving, hasError) that could be shared, 7) Remove any console.log or debug statements added during development, 8) Check for unused state variables from old optimistic patterns, 9) Verify no dead code paths remain from the old implementation, 10) Run 'npm run lint' and fix any unused variable warnings.
-[ ] NAME:Phase 5.7: Final commit and deployment preparation DESCRIPTION:Prepare for deployment: 1) Run full test suite to ensure no regressions, 2) Fix any remaining TypeScript errors or warnings, 3) Run linter and fix any issues, 4) Create comprehensive git commit with message: 'feat: implement optimistic queue pattern with loading states and retry across all components - accessories, line items, and photos now show saving/saved/error states with disabled actions during save and retry on failure', 5) Update CHANGELOG.md with new features and improvements, 6) Create PR if using feature branch workflow, 7) Tag commit with version number if applicable, 8) Prepare deployment notes highlighting new UX improvements for users.
-[x] NAME:Fix duplicate line item render in EstimateTab after add DESCRIPTION:Prevent visual duplication when adding a line item: 1) Stop assigning client UUID in QuickAddLineItem so queue always uses a temp- id; 2) Ensure service preserves server-side id and queue replaces temp with real; 3) Update all calculations and flags in EstimateTab to use lineItems.value (queue) instead of estimate.line_items; 4) Verify no duplicate rows and no second network call; 5) Add quick test: add item, wait 5s, ensure only 1 row present.
-[ ] NAME:EstimateTab: add saving/error status indicators for line items DESCRIPTION:Add UX parity with accessories: 1) show a small spinner for rows being saved; 2) disable delete/edit while saving; 3) show error icon and a Retry button when onCreate fails; 4) minimal, consistent styling with accessories.
-[x] NAME:EstimateTab: make queue parent reactive to props.estimate.line_items DESCRIPTION:Replace queue source from `estimate ? estimate.line_items : []` to `props.estimate ? props.estimate.line_items : []` so Svelte 5 reactivity tracks parent updates. Acceptance: no console warning 'This reference only captures the initial value of estimate', and line items stay in sync with parent after any service call.
-[ ] NAME:Generate Report API: harden report number generation against race conditions DESCRIPTION:In src/routes/api/generate-report/+server.ts, replace `count + 1` approach with a race-safe generator (Postgres sequence or unique constraint + retry). Acceptance: concurrent requests produce unique `REP-YYYY-xxxxx` without duplicate violations.
-[ ] NAME:Generate Report API: robustness pass for partial/missing related data DESCRIPTION:Audit generateReportHTML and data fetches: ensure missing `vehicleIdentification`, `exterior360`, `interiorMechanical`, `damageRecord`, `estimate`, `repairer`, `tyres` don’t crash rendering; provide sensible defaults. Add defensive null checks in template. Acceptance: endpoint returns complete PDF or clear error for truly blocking cases only.
-[ ] NAME:Generate Report API: storage/path and idempotent regenerate check DESCRIPTION:Confirm bucket `documents` RLS allows server-side write; ensure prior file removal errors don’t abort; keep `upsert: true`; path format `assessments/{assessmentId}/reports/{assessment_number}_Report_{timestamp}.pdf` is consistent. Acceptance: re-running replaces the path on assessment, old file is deleted when present (log shows delete), new file exists and is public.
-[ ] NAME:Generate Report API: streaming/progress contract and timeouts DESCRIPTION:Verify streaming response contract (fields: status, progress, message, url). Add upper bound timeout for PDF generation and surface progress messages. Acceptance: Large assessments still stream progress, and job times out gracefully with error if PDF engine stalls.
-[ ] NAME:Generate Report API: tests/manual checklist DESCRIPTION:Create manual runbook: 1) trigger with valid assessment; 2) watch network stream; 3) confirm file in Storage; 4) confirm assessment.report_pdf_url/path/documents_generated_at updated; 5) re-run to confirm deletion of previous; 6) simulate missing subtables (e.g., no tyres) and confirm graceful PDF; 7) high-concurrency test for report numbers.
-[x] NAME:useOptimisticQueue: support reactive parent source via getter DESCRIPTION:Change useOptimisticQueue to accept T[] or () => T[] so $effect reads parent reactively. Acceptance: Passing a getter in children causes queue to sync when parent props change without remounting; no more 'initial value' console warnings.
-[/] NAME:EstimateTab: fix add/delete refresh regressions with reactive queue DESCRIPTION:Use queue getter (() => props.estimate?.line_items ?? []) and ensure UI renders from queue. Acceptance: 1) Add: item renders immediately (temp-), remains after server returns; 2) Delete: item is removed immediately and stays removed after tab switch; 3) No need to refresh tab to see changes.
-[ ] NAME:Regression verification: line items add/delete DESCRIPTION:Run manual checks: 1) Quick add: row appears instantly, no duplicates, one PATCH; 2) Delete a real item: row disappears instantly, parent returns without it; 3) Switch tabs and back: state remains correct; 4) Simulate slow network: pending delete hidden via queue, add shows temp row; 5) Confirm no console 'initial value' warnings.
-[ ] NAME: DESCRIPTION:
-[ ] NAME:Current Task List DESCRIPTION:Root task for conversation __NEW_AGENT__
-[ ] NAME:Commit current state before implementing optimistic queue pattern DESCRIPTION:Create a git commit with all current changes to establish a safe restore point before implementing the comprehensive optimistic queue pattern. This allows easy revert if issues arise. Commit message should be: 'feat: optimistic UI updates with useOptimisticArray - pre-queue-pattern checkpoint'
-[ ] NAME:Current Task List DESCRIPTION:Root task for conversation __NEW_AGENT__